---

mindmap-plugin: basic

---

# 기타

## 프로그래밍 패러다임 ^d8ea0a4f-b79f-d45d
- 목적
   - 패러다임은 무엇을 해야할지를 말하기 보다는 무엇을 해서는 안되는지를 말해준다.
      - 구조적 프로그래밍
         - 제어흐름의 직접적인 전환에 부과되는 규율
      - 객체지향
         - 제어 흐름의 간접적인 전환에 부과되는 규율
      - 함수형 프로그래밍
         - 변수 할당에 부과되는 규율
- 종류
   - 객체지향
      - SOLID
         - 목적
            - 객체지향적 설계의 다섯 가지 기본 원칙
            - 잘 만들어진 벽돌 - 소프트웨어 구조를 정의하는 데 도움을 준다
            - 소프트웨어 설계 원칙 모음
         - 구성
            - SRP : 단일 책임 원칙
               - 정의
                  - 각 소프트웨어 모듈은 변경의 이유가 단 하나여야 한다
                  - 하나의 모듈은 하나의 액터에 대해서만 책임져야 한다
               - 기타 ^d6d4c35f-b832-4030
                  - 메서드와 클래스 수준의 원칙이다
                  - 컴포넌트 수준에서는 CCP : 공통 폐쇄 원칙으로 등장
            - OCP : 개방 폐쇄 원칙
               - 정의
                  - 소프트웨어 개체는 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다
            - LSP : 리스코프 치환 원칙
               - 정의
                  - 상위 타입의 객체를 하위 타입의 객체로 치환해도 동작에 문제가 없어야 한다
                  - 초기에는 상속 가이드라인으로 쓰였으나, 시간이 지나며 인터페이스와 구현체에도 적용되는 설계원칙이 되었음
            - ISP : 인터페이스 분리 원칙
               - 정의
                  - 인터페이스는 ‘그 인터페이스를 사용하는 클라이언트’를 기준으로 분리해야 한다.
                  - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
                  - 인터페이스를 분리하게 되면 인터페이스가 명확해지고, 대체 가능성이 높아진다.
               - 예시
                  - 인터페이스에 A,B,C,D 가 들어있는데 A,B만 자주쓰이고 C,D는 잘 안쓰인다면 A,B랑 C,D는 분리하는게.. 안그러면 해당 인터페이스를 구현할때 마다 쓰이지는 않는데 매번 불필요한 C,D를 구현해야 함
            - DIP : 의존성 역전 원칙
               - 정의
                  - 객체는 저수준 모듈보다 고수준 모듈에 의존해야 한다
                     - 고수준 모듈 : 인터페이스 혹은 추상개념
                     - 저수준 모듈 : 구현체
                  - 세부사항이 정책에 의존해야 한다
      - 특징(?)
         - 다형성
            - 정의
               - 프로그램 언어의 각 요소들(상수, 변수, 식, 오브젝트, 함수, 메소드 등)이 다양한 자료형(type)에 속하는 것이 허가되는 성질
            - 장점
               - 반복된 코드를 줄이며 꼭 필요한 코드만 수정할 수 있다
               - 변화하는 요구사항에 보다 유연하게 대처할 수 있다
            - 질문
               - 상속과 무엇이 다른가?.. LSP에 따르면 상속도 다형성에 포함되어야 하는 것이 아닐까? 왜 분리되어있을까?
         - 상속
            - 정의
               - 객체들 간의 관계를 구축하는 방법
            - 장점
               - 코드를 재사용할 수 있다
               - 다형성을 구현할 수 있다
            - 질문
               - 객체들간의 관계를 구축하는 방법인데, 코드를 재사용하는것에 대한 목적으로 쓰는게 뭔가 이상하다고 생각됨, 물론 재사용이 가능하겠지만 뭔가 그냥 말투가 찝찝함
            - 주의사항
               - IS-A 관계에 사용하는 것이 좋다
                  - HAS-A 관계라면
                     - 이펙티브자바 아이템18 -상속보다는 컴포지션을 사용하라
                     - LSP 위반
               - 이미 정의된 메소드를 재정의하지 말자
                  - 재정의시
                     - LSP 위반
               - 인스턴스 필드는 되도록 private로 설정하자
                  - 아니라면
                     - 캡슐화의 이점이 줄어든다
            - 기타
         - 캡슐화
            - 정의
               - 객체의 속성(data fields)과 행위(methods)를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉한다
            - 목적
               - 변경에 유연한 프로그램을 만드는 동시에 보안적인 프로그램을 만들기 위해
                  - 잘 이루어지지 않는다면?
                     - 객체가 스스로의 상태를 처리하지 못한다
                     - 외부에서 속성을 꺼내와서 상태를 수정하게 되면 높은 결합도와 낮은 응집도를 지닌 수동적인 객체가 된다
                     - 외부에서 수정되기 쉬운 수동적인 객체는 프로그램의 유지 보수를 어렵게 한다
            - 기타
               - 객체에게 메시지를 던지는 사고가 캡슐화를 지키는 지름길!!!
         - 추상화
            - 정의
               - 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 일반화를 통해 간추려 내는 것
                  - ↔ 구체화
            - 목적
               - 현실세계의 복잡한 문제들을 소프트웨어 시스템으로 모델링 할때
                  공통적이고, 핵심적인 부분들만을 취해서 가져올 수 있음
         - 질문
            - SOLID랑 4원칙이 어떻게 다른가?? 설계 5원칙과 그냥 특징인가?
               - SOLID 객체지향 4가지 특징을 최대한 살리기 위해 고안된 설계원칙!!
         - 참고
            - https://steady-coding.tistory.com/449
   - 함수형 프로그래밍
      - 특징
         - 순수함수 사용
            - `동일한` 입력값을 넣었을 때 항상 `동일한` 리턴값을 반환하며 외부에 영향을 받지 않는 함수
               - 함수의 실행이 프로그램에 영향을 주지 않음
            - 비상태 불변성 유지
               - 전달된 데이터를 변경하는 것이 아니라 새로운 버전, 새로운 오브젝트를 만들어서 결과값으로 전달해야함
            - 여러가지 동시다발적인 멀티쓰레딩 환경에서도 안정적으로 동작할 수 있음
   - 절차지향 ^17e6a0c0-6345-a600
      - 일이 진행되는 순서대로 프로그래밍하는 방법
      - 특징
         - 프로그램 규모가 커질수록 유지보수 및 분석이 어려움
- 일급 객체(
   - 객체지향
      - 객체
   - 함수형프로그래밍
      - 함수
   - 정의
      - 모든 일급객체는
         - 함수의 매개변수가 될 수 있다
         - 함수의 반환값이 될 수 있다
         - 할당의 대상이 될 수 있다
         - 비교연산을 적용할 수 있다
   - Sub title

## JWT
- 정의
   - 인증에 필요한 정보들을 암호화시킨 JSON 토큰
   - 헤더.페이로드.서명
      - 헤더
         - 타입(토큰 유형)과 해시 알고리즘의 종류
      - 페이로드
         - 서버에서 첨부한 사용자 권한정보와 데이터
         - 토큰에서 사용할 정보의 조각들인 Claim 이 담겨있다
         - key-value 형식으로 이루어진 한 쌍의 정보를 Claim이라고 칭한다.
         - 정해진 데이터 타입은 없지만 대표적으로
            - iss : 발행자
            - iat: 발행시간
            - exp:만료시간
            - sub: 제목
      - 서명
         - 헤더, 페이로드를 Base64 URL-safe Encode 를 한 후
            헤더에 명시된 해시함수를 적용후, 개인키로 서명한 전자서명
   - 인증 신뢰성을 가지는 이유
      - 다른 유저가 페이로드 부분을 변경했을경우 시그니처가 불일치하기 때문
      - 정보 보호가 아닌 위조 방지의 목적을 가지고 있음
- 장점
   - 인증을 위한 별도의 저장소가 없어 빠른 인증처리가 가능하고, 확장성이 우수하다
   - 세션 저장소 사용으로 인한 서버부하가 없음
- 단점
   - 특정 토큰을 강제로 만료시키기 어려움

## 애자일 ^df7210c6-dbc6-84dc
- 정의
   - 우리가 일할때 함게 지키면 좋을 가치
- 방법론
   - 스크럼
      - 역할
         - PO
            - 모든 이해관계자의 입장을 대변하는 사람
            - 방향을 정하고 결정을 내리는 사람
            - 끊임없이 배우고 또 배우는 사람
         - 스크럼마스터
            - 스크럼과 애자일의 가치를 잊지 않게 해주는 사람
            - 보다 효율적이고 효과적으로 일하는 방법을 고민하는 사람
            - 헌신적인 리더
               - 끊임없이 질문을 해서 무언가 깨닫게 해주는 소크라테스 처럼 행동한다
               - 고민보다 실행부터 하도록 가이드 해줌
               - 팀을 보호해야 하는 역할
         - 개발자들
            - 스스로 주체적으로 일하는 사람들
            - 교차기능적으로 협업하는 T자형인재
            - 기술적 채무를 만들지 않는 사람들
      - 구성
         - 비전 → 로드맵 → 프로덕트 백로그 → 릴리즈 플래닝
         - 스프린트 플래닝 → 스프린트백로그 → 데일리스크럼(반복) → 리뷰 → 회고
      - 특징
         - 스프린트 안에서 시작한 일은 스프린트 단위 안에서 끝내야 한다.
         - 매 스프린트는 이전 스프린트보다 나아져야
         - 스프린트 중간에는 새로운 일이 추가되면 X
   - 칸반
   - XP

## 객체지향적인 코드는?
- 어떠한 객체도 섬이 아니다

## 테스트
- DCI 패턴으로 작성했음
   - Describe-Context-It
- 테스트 커버리지 강제는 힘들었음
   - 불필요한 테스트코드까지 작성하게 된게 큰 이유인듯
   - 조금 조금씩 모두 늦어지니 절차가 너무 복잡해졌음

## 코드리뷰
- 클린코드 기반
- IF/ELSE
- SRP

## 시큐리티
- 회원가입/로그인 기능 구현 방식
   - 스프링시큐리티
      - 인증과 권한 부여를 사용해 접근을 제어하는 프레임워크
   - SecurityConfig
      - 인증
         - Authentication
      - 권한
         - Authorization
- csrf 필터
   - 사이트 간 요청 위조(Cross-site request forgery, CSRF)
      웹사이트 취약점 공격
      - 쿠키에 담긴 sessionID를 통해 해당 요청이 인증된 사용자로부터 온 것으로 판단하고 처리합니다.
   - 사용자가 자신의 의지와는 무관하게
      공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 하는 공격
   - 필터가 하는 일
      - 요청마다 랜덤하게 토큰을 생성하고, 클라이언트에게 그것을 발급하는 일
      - 클라이언트가 서버의 자원에 접근할 때는 반드시 이 토큰을 헤더에 포함해서 와야한다
      - 토큰이 포함되지 않거나 일치하지 않을 경우 요청 실패
   - 껐던 이유
      - rest api를 이용한 서버라면, session 기반 인증과는 다르게 stateless하기 때문에
      - rest api에서 client는 권한이 필요한 요청을 하기 위해서
         요청에 필요한 인증 정보를(OAuth2, jwt토큰 등)을 포함시켜야 한다
      - 서버에 인증정보를 저장하지 않기 때문에 굳이 불필요한 csrf 코드들을 작성할 필요가 없다
   - 기타
      - Spring의 View Template 역할을 하는 타임리프는
         개발자가 별도로 생성하지 않아도 POST 요청을 할 때 CSRF Token을 자동으로 생성해준다고 한다
- OAuth
   - OAuth를 사용하지 않았을 때 구현해야 하는 것
      - 로그인 시 보안
      - 회원가입 시 이메일 혹은 전화번호 인증
      - 비밀번호 변경
- Token
   - AccessToken
   - RefreshToken
   - 관리
      - AccessToken을 1시간 / RefreshToken을 2시간으로 지정
      - 만료된 AccessToken의 Principle을 이용해서 RefreshToken이 만료되지 않았다면 갱신
   - 배운부분
      - 에러메시지를 AccessToken과 RefreshToken을 모두 만료된 토큰입니다. 라고 관리하고 있었음
      - 좋았던 점은, 이전에 클론코딩을 하면서도 Security를 담당했었고 이때는 원하는 로직대로 잘 실행되면 패스
      - 프론트가 붙고 사용하기 시작하면서 발견된점
         - 모두 만료된 토큰으로 관리되고 있었던 에러 메시지
            - 프론트랑 붙어서 협업을 하는 것이니까
               상태코드 이외에 에러코드같은걸 지정해서 관리했으면 좋았을 듯
- 프로토콜
   - Authorization Code Grant
      (인가 코드 승인 방식)
      - 권한 서버가 클라이언트와 리소스 서버 간의 중재를 해준다
      - 서버사이드 방식의 인증으로 인증을 서버에서 처리한다.
      - URL에 response-type=code으로 넘긴다.
   - Implicit Grant
      (암묵적 승인)
      - Client 기반의 애플리케이션이나 모바일 애플리케이션에 주로 사용
         - JS기반의 프론트 서버 혹은 안드로이드, iOS
      - 권한 코드를 따로 발급하지 않아 보안에는 취약하다
         - 사용자에게 권한 코드를 넘기고 클라이언트가 권한 코드를 받아서 매칭 해보는 과정이 없다.
      - 주로 자원을 "읽기 전용"으로 사용한다.
      - URL에 response-type=token으로 넘긴다.
   - Resource Owner Password Credentials Grant
      (리소스 소유자 암호 자격 승인)
      - Client에 ID & PW를 저장해놓고 ID & PW로 직접 토큰을 받아오는 방식
      - Client가 신뢰할 수 없는 경우 보안에 취약
   - Client Credentials Grant
      - id와 secret을 가지고 인증하는 방식

## 블로킹 vs 논블로킹
- 블로킹
- 논블로킹

## 동기 vs 비동기
- 동기
   - 함수 A가 함수 B를 호출한 뒤, 함수 B의 리턴값을 계속 확인하면서 신경쓰는 것
- 비동기
   - 함수 A가 함수 B를 호출할 때 콜백 함수를 함께 전달해서,
      함수 B의 작업이 완료되면 함께 보낸 콜백 함수를 실행한다.
   - 함수 A는 함수 B를 호출한 후로 함수 B의 작업 완료 여부에는 신경쓰지 않는다.